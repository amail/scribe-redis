From 7ef60d5460ccf31bf854c16335773a6564c88410 Mon Sep 17 00:00:00 2001
From: Jack Engqvist Johansson <jack.johansson@comfirm.se>
Date: Fri, 24 Feb 2012 18:20:33 +0000
Subject: [PATCH] Added redis support. Todo: look for hiredis in config scripts...

---
 src/Makefile.am |    3 +-
 src/store.cpp   | 1056 +++++++++++++++++++++----------------------------------
 src/store.h     |  192 +++++------
 3 files changed, 483 insertions(+), 768 deletions(-)

diff --git a/src/Makefile.am b/src/Makefile.am
index 969775a..785a042 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -53,7 +53,7 @@ endif
 
 # Set libraries external to this component.
 EXTERNAL_LIBS = -L$(thrift_home)/lib -L$(fb303_home)/lib -L$(hadoop_home)/lib -lfb303 -lthrift -lthriftnb
-EXTERNAL_LIBS += -levent -lpthread
+EXTERNAL_LIBS += -levent -lpthread -lhiredis
 if USE_SCRIBE_HDFS
   EXTERNAL_LIBS += -lhdfs -ljvm
 endif
@@ -69,6 +69,7 @@ AM_CPPFLAGS += -I$(thrift_home)/include/thrift
 AM_CPPFLAGS += -I$(fb303_home)/include/thrift
 AM_CPPFLAGS += -I$(fb303_home)/include/thrift/fb303
 AM_CPPFLAGS += -I$(hadoop_home)/include
+AM_CPPFLAGS += -I$(thrift_home)/include/hiredis
 AM_CPPFLAGS += $(BOOST_CPPFLAGS)
 AM_CPPFLAGS += $(FB_CPPFLAGS) $(DEBUG_CPPFLAGS)
 
diff --git a/src/store.cpp b/src/store.cpp
index cc2f6a5..b516645 100644
--- a/src/store.cpp
+++ b/src/store.cpp
@@ -22,12 +22,10 @@
 // @author Avinash Lakshman
 // @author Anthony Giardullo
 // @author Jan Oravec
-// @author John Song
 
-#include <algorithm>
 #include "common.h"
 #include "scribe_server.h"
-#include "network_dynamic_config.h"
+#include "thrift/transport/TSimpleFileTransport.h"
 
 using namespace std;
 using namespace boost;
@@ -38,90 +36,55 @@ using namespace apache::thrift::transport;
 using namespace apache::thrift::server;
 using namespace scribe::thrift;
 
-#define DEFAULT_FILESTORE_MAX_SIZE                1000000000
-#define DEFAULT_FILESTORE_MAX_WRITE_SIZE          1000000
-#define DEFAULT_FILESTORE_ROLL_HOUR               1
-#define DEFAULT_FILESTORE_ROLL_MINUTE             15
-#define DEFAULT_BUFFERSTORE_SEND_RATE             1
-#define DEFAULT_BUFFERSTORE_AVG_RETRY_INTERVAL    300
-#define DEFAULT_BUFFERSTORE_RETRY_INTERVAL_RANGE  60
-#define DEFAULT_BUCKETSTORE_DELIMITER             ':'
-#define DEFAULT_NETWORKSTORE_CACHE_TIMEOUT        300
-#define DEFAULT_BUFFERSTORE_BYPASS_MAXQSIZE_RATIO 0.75
-
-// magic threshold
-#define DEFAULT_NETWORKSTORE_DUMMY_THRESHOLD      4096
-
-// Parameters for adaptive_backoff
-#define DEFAULT_MIN_RETRY                         5
-#define DEFAULT_MAX_RETRY                         100
-#define DEFAULT_RANDOM_OFFSET_RANGE               20
-const double MULT_INC_FACTOR =                    1.414; //sqrt(2)
-#define ADD_DEC_FACTOR                            2
-#define CONT_SUCCESS_THRESHOLD                    1
+#define DEFAULT_FILESTORE_MAX_SIZE               1000000000
+#define DEFAULT_FILESTORE_MAX_WRITE_SIZE         1000000
+#define DEFAULT_FILESTORE_ROLL_HOUR              1
+#define DEFAULT_FILESTORE_ROLL_MINUTE            15
+#define DEFAULT_BUFFERSTORE_MAX_QUEUE_LENGTH     2000000
+#define DEFAULT_BUFFERSTORE_SEND_RATE            1
+#define DEFAULT_BUFFERSTORE_AVG_RETRY_INTERVAL   300
+#define DEFAULT_BUFFERSTORE_RETRY_INTERVAL_RANGE 60
+#define DEFAULT_BUCKETSTORE_DELIMITER            ':'
+#define DEFAULT_NETWORKSTORE_CACHE_TIMEOUT       300
 
 ConnPool g_connPool;
 
 const string meta_logfile_prefix = "scribe_meta<new_logfile>: ";
 
-// Checks if we should try sending a dummy Log in the n/w store
-bool shouldSendDummy(boost::shared_ptr<logentry_vector_t> messages) {
-  size_t size = 0;
-  for (logentry_vector_t::iterator iter = messages->begin();
-      iter != messages->end(); ++iter) {
-    size += (**iter).message.size();
-    if (size > DEFAULT_NETWORKSTORE_DUMMY_THRESHOLD) {
-      return true;
-    }
-  }
-  return false;
-}
-
-
 boost::shared_ptr<Store>
-Store::createStore(StoreQueue* storeq, const string& type,
-                   const string& category, bool readable,
-                   bool multi_category) {
+Store::createStore(const string& type, const string& category,
+                   bool readable, bool multi_category) {
   if (0 == type.compare("file")) {
-    return shared_ptr<Store>(new FileStore(storeq, category, multi_category,
-                                          readable));
+    return shared_ptr<Store>(new FileStore(category, multi_category, readable));
   } else if (0 == type.compare("buffer")) {
-    return shared_ptr<Store>(new BufferStore(storeq,category, multi_category));
+    return shared_ptr<Store>(new BufferStore(category, multi_category));
+  } else if (0 == type.compare("redis")) {
+    return shared_ptr<Store>(new RedisStore(category, multi_category));
   } else if (0 == type.compare("network")) {
-    return shared_ptr<Store>(new NetworkStore(storeq, category,
-                                              multi_category));
+    return shared_ptr<Store>(new NetworkStore(category, multi_category));
   } else if (0 == type.compare("bucket")) {
-    return shared_ptr<Store>(new BucketStore(storeq, category,
-                                            multi_category));
+    return shared_ptr<Store>(new BucketStore(category, multi_category));
   } else if (0 == type.compare("thriftfile")) {
-    return shared_ptr<Store>(new ThriftFileStore(storeq, category,
-                                                multi_category));
+    return shared_ptr<Store>(new ThriftFileStore(category, multi_category));
   } else if (0 == type.compare("null")) {
-    return shared_ptr<Store>(new NullStore(storeq, category, multi_category));
+    return shared_ptr<Store>(new NullStore(category, multi_category));
   } else if (0 == type.compare("multi")) {
-    return shared_ptr<Store>(new MultiStore(storeq, category, multi_category));
+    return shared_ptr<Store>(new MultiStore(category, multi_category));
   } else if (0 == type.compare("category")) {
-    return shared_ptr<Store>(new CategoryStore(storeq, category,
-                                              multi_category));
+    return shared_ptr<Store>(new CategoryStore(category, multi_category));
   } else if (0 == type.compare("multifile")) {
-    return shared_ptr<Store>(new MultiFileStore(storeq, category,
-                                                multi_category));
+    return shared_ptr<Store>(new MultiFileStore(category, multi_category));
   } else if (0 == type.compare("thriftmultifile")) {
-    return shared_ptr<Store>(new ThriftMultiFileStore(storeq, category,
-                                                      multi_category));
+    return shared_ptr<Store>(new ThriftMultiFileStore(category, multi_category));
   } else {
     return shared_ptr<Store>();
   }
 }
 
-Store::Store(StoreQueue* storeq,
-             const string& category,
-             const string &type,
-             bool multi_category)
+Store::Store(const string& category, const string &type, bool multi_category)
   : categoryHandled(category),
     multiCategory(multi_category),
-    storeType(type),
-    storeQueue(storeq) {
+    storeType(type) {
   pthread_mutex_init(&statusMutex, NULL);
 }
 
@@ -129,11 +92,6 @@ Store::~Store() {
   pthread_mutex_destroy(&statusMutex);
 }
 
-void Store::configure(pStoreConf configuration, pStoreConf parent) {
-  storeConf = configuration;
-  storeConf->setParent(parent);
-}
-
 void Store::setStatus(const std::string& new_status) {
   pthread_mutex_lock(&statusMutex);
   status = new_status;
@@ -149,26 +107,22 @@ std::string Store::getStatus() {
 
 bool Store::readOldest(/*out*/ boost::shared_ptr<logentry_vector_t> messages,
                        struct tm* now) {
-  LOG_OPER("[%s] ERROR: attempting to read from a write-only store",
-          categoryHandled.c_str());
+  LOG_OPER("[%s] ERROR: attempting to read from a write-only store", categoryHandled.c_str());
   return false;
 }
 
 bool Store::replaceOldest(boost::shared_ptr<logentry_vector_t> messages,
                           struct tm* now) {
-  LOG_OPER("[%s] ERROR: attempting to read from a write-only store",
-          categoryHandled.c_str());
+  LOG_OPER("[%s] ERROR: attempting to read from a write-only store", categoryHandled.c_str());
   return false;
 }
 
 void Store::deleteOldest(struct tm* now) {
-   LOG_OPER("[%s] ERROR: attempting to read from a write-only store",
-            categoryHandled.c_str());
+   LOG_OPER("[%s] ERROR: attempting to read from a write-only store", categoryHandled.c_str());
 }
 
 bool Store::empty(struct tm* now) {
-  LOG_OPER("[%s] ERROR: attempting to read from a write-only store",
-            categoryHandled.c_str());
+  LOG_OPER("[%s] ERROR: attempting to read from a write-only store", categoryHandled.c_str());
   return true;
 }
 
@@ -176,10 +130,9 @@ const std::string& Store::getType() {
   return storeType;
 }
 
-FileStoreBase::FileStoreBase(StoreQueue* storeq,
-                             const string& category,
-                             const string &type, bool multi_category)
-  : Store(storeq, category, type, multi_category),
+FileStoreBase::FileStoreBase(const string& category, const string &type,
+                             bool multi_category)
+  : Store(category, type, multi_category),
     baseFilePath("/tmp"),
     subDirectory(""),
     filePath("/tmp"),
@@ -197,7 +150,6 @@ FileStoreBase::FileStoreBase(StoreQueue* storeq,
     writeCategory(false),
     createSymlink(true),
     writeStats(false),
-    rotateOnReopen(false),
     currentSize(0),
     lastRollTime(0),
     eventsWritten(0) {
@@ -206,8 +158,7 @@ FileStoreBase::FileStoreBase(StoreQueue* storeq,
 FileStoreBase::~FileStoreBase() {
 }
 
-void FileStoreBase::configure(pStoreConf configuration, pStoreConf parent) {
-  Store::configure(configuration, parent);
+void FileStoreBase::configure(pStoreConf configuration) {
 
   // We can run using defaults for all of these, but there are
   // a couple of suspicious things we warn about.
@@ -227,9 +178,7 @@ void FileStoreBase::configure(pStoreConf configuration, pStoreConf parent) {
 
 
   if (!configuration->getString("base_filename", baseFileName)) {
-    LOG_OPER(
-        "[%s] WARNING: Bad config - no base_filename specified for file store",
-        categoryHandled.c_str());
+    LOG_OPER("[%s] WARNING: Bad config - no base_filename specified for file store", categoryHandled.c_str());
   }
 
   // check if symlink name is optionally specified
@@ -273,8 +222,8 @@ void FileStoreBase::configure(pStoreConf configuration, pStoreConf parent) {
 
       if (!ok) {
         rollPeriod = ROLL_NEVER;
-        LOG_OPER("[%s] WARNING: Bad config - invalid format of rotate_period, rotations disabled",
-            categoryHandled.c_str());
+        LOG_OPER("[%s] WARNING: Bad config - invalid format of rotate_period,"
+                 " rotations disabled", categoryHandled.c_str());
       }
     }
   }
@@ -309,21 +258,10 @@ void FileStoreBase::configure(pStoreConf configuration, pStoreConf parent) {
   configuration->getString("fs_type", fsType);
 
   configuration->getUnsigned("max_size", maxSize);
-  if(0 == maxSize) {
-    maxSize = ULONG_MAX;
-  }
   configuration->getUnsigned("max_write_size", maxWriteSize);
   configuration->getUnsigned("rotate_hour", rollHour);
   configuration->getUnsigned("rotate_minute", rollMinute);
   configuration->getUnsigned("chunk_size", chunkSize);
-
-  if (configuration->getString("rotate_on_reopen", tmp)) {
-    if (0 == tmp.compare("yes")) {
-      rotateOnReopen = true;
-    } else {
-      rotateOnReopen = false;
-    }
-  }
 }
 
 void FileStoreBase::copyCommon(const FileStoreBase *base) {
@@ -341,7 +279,6 @@ void FileStoreBase::copyCommon(const FileStoreBase *base) {
   createSymlink = base->createSymlink;
   baseSymlinkName = base->baseSymlinkName;
   writeStats = base->writeStats;
-  rotateOnReopen = base->rotateOnReopen;
 
   /*
    * append the category name to the base file path and change the
@@ -358,10 +295,9 @@ void FileStoreBase::copyCommon(const FileStoreBase *base) {
 }
 
 bool FileStoreBase::open() {
-  return openInternal(rotateOnReopen, NULL);
+  return openInternal(false, NULL);
 }
 
-// Decides whether conditions are sufficient for us to roll files
 void FileStoreBase::periodicCheck() {
 
   time_t rawtime = time(NULL);
@@ -402,8 +338,7 @@ void FileStoreBase::rotateFile(time_t currentTime) {
 
   LOG_OPER("[%s] %d:%d rotating file <%s> old size <%lu> max size <%lu>",
            categoryHandled.c_str(), timeinfo.tm_hour, timeinfo.tm_min,
-           makeBaseFilename(&timeinfo).c_str(), currentSize,
-           maxSize == ULONG_MAX ? 0 : maxSize);
+           makeBaseFilename(&timeinfo).c_str(), currentSize, maxSize);
 
   printStats();
   openInternal(true, &timeinfo);
@@ -490,8 +425,7 @@ int FileStoreBase::findOldestFile(const string& base_filename) {
   return min_suffix;
 }
 
-int FileStoreBase::getFileSuffix(const string& filename,
-                                const string& base_filename) {
+int FileStoreBase::getFileSuffix(const string& filename, const string& base_filename) {
   int suffix = -1;
   string::size_type suffix_pos = filename.rfind('_');
 
@@ -515,8 +449,7 @@ void FileStoreBase::printStats() {
   string filename(filePath);
   filename += "/scribe_stats";
 
-  boost::shared_ptr<FileInterface> stats_file =
-      FileInterface::createFileInterface(fsType, filename);
+  boost::shared_ptr<FileInterface> stats_file = FileInterface::createFileInterface(fsType, filename);
   if (!stats_file ||
       !stats_file->createDirectory(filePath) ||
       !stats_file->openWrite()) {
@@ -550,8 +483,7 @@ unsigned long FileStoreBase::bytesToPad(unsigned long next_message_length,
                                         unsigned long chunk_size) {
 
   if (chunk_size > 0) {
-    unsigned long space_left_in_chunk =
-              chunk_size - current_file_size % chunk_size;
+    unsigned long space_left_in_chunk = chunk_size - current_file_size % chunk_size;
     if (next_message_length > space_left_in_chunk) {
       return space_left_in_chunk;
     } else {
@@ -587,20 +519,18 @@ void FileStoreBase::setHostNameSubDir() {
   }
 }
 
-FileStore::FileStore(StoreQueue* storeq,
-                     const string& category,
-                     bool multi_category, bool is_buffer_file)
-  : FileStoreBase(storeq, category, "file", multi_category),
+FileStore::FileStore(const string& category, bool multi_category,
+                     bool is_buffer_file)
+  : FileStoreBase(category, "file", multi_category),
     isBufferFile(is_buffer_file),
-    addNewlines(false),
-    lostBytes_(0) {
+    addNewlines(false) {
 }
 
 FileStore::~FileStore() {
 }
 
-void FileStore::configure(pStoreConf configuration, pStoreConf parent) {
-  FileStoreBase::configure(configuration, parent);
+void FileStore::configure(pStoreConf configuration) {
+  FileStoreBase::configure(configuration);
 
   // We can run using defaults for all of these, but there are
   // a couple of suspicious things we warn about.
@@ -650,12 +580,7 @@ bool FileStore::openInternal(bool incrementFilename, struct tm* current_time) {
 
     // this is the case where there's no file there and we're not incrementing
     if (suffix < 0) {
-      if (rollPeriod == ROLL_HOURLY) {
-        suffix = current_time->tm_hour;
-      }
-      else {
-        suffix = 0;
-      }
+      suffix = 0;
     }
 
     string file = makeFullFilename(suffix, current_time);
@@ -733,7 +658,7 @@ bool FileStore::openInternal(bool incrementFilename, struct tm* current_time) {
       setStatus("");
     }
 
-  } catch(const std::exception& e) {
+  } catch(std::exception const& e) {
     LOG_OPER("[%s] Failed to create/open file of type <%s> for writing",
              categoryHandled.c_str(), fsType.c_str());
     LOG_OPER("Exception: %s", e.what());
@@ -761,8 +686,7 @@ void FileStore::flush() {
 }
 
 shared_ptr<Store> FileStore::copy(const std::string &category) {
-  FileStore *store = new FileStore(storeQueue, category, multiCategory,
-                                   isBufferFile);
+  FileStore *store = new FileStore(category, multiCategory, isBufferFile);
   shared_ptr<Store> copied = shared_ptr<Store>(store);
 
   store->addNewlines = addNewlines;
@@ -773,11 +697,8 @@ shared_ptr<Store> FileStore::copy(const std::string &category) {
 bool FileStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages) {
 
   if (!isOpen()) {
-    if (!open()) {
-      LOG_OPER("[%s] File failed to open FileStore::handleMessages()",
-               categoryHandled.c_str());
-      return false;
-    }
+    LOG_OPER("[%s] File failed to open FileStore::handleMessages()", categoryHandled.c_str());
+    return false;
   }
 
   // write messages to current file
@@ -861,7 +782,7 @@ bool FileStore::writeMessages(boost::shared_ptr<logentry_vector_t> messages,
       num_buffered++;
 
       // Write buffer if processing last message or if larger than allowed
-      if ((current_size_buffered > max_write_size && maxSize != 0) ||
+      if ((currentSize + current_size_buffered > max_write_size && maxSize != 0) ||
           messages->end() == iter + 1 ) {
         if (!write_file->write(write_buffer)) {
           LOG_OPER("[%s] File store failed to write (%lu) messages to file",
@@ -884,7 +805,7 @@ bool FileStore::writeMessages(boost::shared_ptr<logentry_vector_t> messages,
         write_file = writeFile;
       }
     }
-  } catch (const std::exception& e) {
+  } catch (std::exception const& e) {
     LOG_OPER("[%s] File store failed to write. Exception: %s",
              categoryHandled.c_str(), e.what());
     success = false;
@@ -904,8 +825,6 @@ bool FileStore::writeMessages(boost::shared_ptr<logentry_vector_t> messages,
   return success;
 }
 
-// Deletes the oldest file
-// currently gets invoked from within a bufferstore
 void FileStore::deleteOldest(struct tm* now) {
 
   int index = findOldestFile(makeBaseFilename(now));
@@ -914,10 +833,6 @@ void FileStore::deleteOldest(struct tm* now) {
   }
   shared_ptr<FileInterface> deletefile = FileInterface::createFileInterface(fsType,
                                             makeFullFilename(index, now));
-  if (lostBytes_) {
-    g_Handler->incCounter(categoryHandled, "bytes lost", lostBytes_);
-    lostBytes_ = 0;
-  }
   deletefile->deleteFile();
 }
 
@@ -960,8 +875,6 @@ bool FileStore::replaceOldest(boost::shared_ptr<logentry_vector_t> messages,
 bool FileStore::readOldest(/*out*/ boost::shared_ptr<logentry_vector_t> messages,
                            struct tm* now) {
 
-  long loss;
-
   int index = findOldestFile(makeBaseFilename(now));
   if (index < 0) {
     // This isn't an error. It's legit to call readOldest when there aren't any
@@ -970,18 +883,15 @@ bool FileStore::readOldest(/*out*/ boost::shared_ptr<logentry_vector_t> messages
   }
   std::string filename = makeFullFilename(index, now);
 
-  shared_ptr<FileInterface> infile = FileInterface::createFileInterface(fsType,
-                                              filename, isBufferFile);
+  shared_ptr<FileInterface> infile = FileInterface::createFileInterface(fsType, filename, isBufferFile);
 
   if (!infile->openRead()) {
-    LOG_OPER("[%s] Failed to open file <%s> for reading",
-            categoryHandled.c_str(), filename.c_str());
+    LOG_OPER("[%s] Failed to open file <%s> for reading", categoryHandled.c_str(), filename.c_str());
     return false;
   }
 
-  uint32_t bsize = 0;
   std::string message;
-  while ((loss = infile->readNext(message)) > 0) {
+  while (infile->readNext(message)) {
     if (!message.empty()) {
       logentry_ptr_t entry = logentry_ptr_t(new LogEntry);
 
@@ -990,11 +900,9 @@ bool FileStore::readOldest(/*out*/ boost::shared_ptr<logentry_vector_t> messages
         // get category without trailing \n
         entry->category = message.substr(0, message.length() - 1);
 
-        if ((loss = infile->readNext(message)) <= 0) {
-          LOG_OPER("[%s] category not stored with message <%s> "
-              "corruption?, incompatible config change?",
-              categoryHandled.c_str(), entry->category.c_str());
-          break;
+        if (!infile->readNext(message)) {
+          LOG_OPER("[%s] category not stored with message <%s>",
+                   categoryHandled.c_str(), entry->category.c_str());
         }
       } else {
         entry->category = categoryHandled;
@@ -1003,23 +911,17 @@ bool FileStore::readOldest(/*out*/ boost::shared_ptr<logentry_vector_t> messages
       entry->message = message;
 
       messages->push_back(entry);
-      bsize += entry->category.size();
-      bsize += entry->message.size();
     }
   }
-  if (loss < 0) {
-    lostBytes_ = -loss;
-  } else {
-    lostBytes_ = 0;
-  }
   infile->close();
 
-  LOG_OPER("[%s] read <%lu> entries of <%d> bytes from file <%s>",
-        categoryHandled.c_str(), messages->size(), bsize, filename.c_str());
+  LOG_OPER("[%s] successfully read <%lu> entries from file <%s>",
+        categoryHandled.c_str(), messages->size(), filename.c_str());
   return true;
 }
 
 bool FileStore::empty(struct tm* now) {
+
   std::vector<std::string> files = FileInterface::list(filePath, fsType);
 
   std::string base_filename = makeBaseFilename(now);
@@ -1029,22 +931,18 @@ bool FileStore::empty(struct tm* now) {
     int suffix =  getFileSuffix(*iter, base_filename);
     if (-1 != suffix) {
       std::string fullname = makeFullFilename(suffix, now);
-      shared_ptr<FileInterface> file = FileInterface::createFileInterface(fsType,
-                                                                      fullname);
+      shared_ptr<FileInterface> file = FileInterface::createFileInterface(fsType, fullname);
       if (file->fileSize()) {
         return false;
       }
     } // else it doesn't match the filename for this store
   }
   return true;
-
 }
 
 
-ThriftFileStore::ThriftFileStore(StoreQueue* storeq,
-                                 const std::string& category,
-                                 bool multi_category)
-  : FileStoreBase(storeq, category, "thriftfile", multi_category),
+ThriftFileStore::ThriftFileStore(const std::string& category, bool multi_category)
+  : FileStoreBase(category, "thriftfile", multi_category),
     flushFrequencyMs(0),
     msgBufferSize(0),
     useSimpleFile(0) {
@@ -1054,7 +952,7 @@ ThriftFileStore::~ThriftFileStore() {
 }
 
 shared_ptr<Store> ThriftFileStore::copy(const std::string &category) {
-  ThriftFileStore *store = new ThriftFileStore(storeQueue, category, multiCategory);
+  ThriftFileStore *store = new ThriftFileStore(category, multiCategory);
   shared_ptr<Store> copied = shared_ptr<Store>(store);
 
   store->flushFrequencyMs = flushFrequencyMs;
@@ -1065,9 +963,7 @@ shared_ptr<Store> ThriftFileStore::copy(const std::string &category) {
 
 bool ThriftFileStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages) {
   if (!isOpen()) {
-    if (!open()) {
-      return false;
-    }
+    return false;
   }
 
   unsigned long messages_handled = 0;
@@ -1075,8 +971,7 @@ bool ThriftFileStore::handleMessages(boost::shared_ptr<logentry_vector_t> messag
        iter != messages->end();
        ++iter) {
 
-    // This length is an estimate -- what the ThriftLogFile actually writes is
-    // a black box to us
+    // This length is an estimate -- what the ThriftLogFile actually writes is a black box to us
     uint32_t length = (*iter)->message.size();
 
     try {
@@ -1084,7 +979,7 @@ bool ThriftFileStore::handleMessages(boost::shared_ptr<logentry_vector_t> messag
       currentSize += length;
       ++eventsWritten;
       ++messages_handled;
-    } catch (const TException& te) {
+    } catch (TException te) {
       LOG_OPER("[%s] Thrift file store failed to write to file: %s\n", categoryHandled.c_str(), te.what());
       setStatus("File write error");
 
@@ -1113,8 +1008,8 @@ bool ThriftFileStore::isOpen() {
   return thriftFileTransport && thriftFileTransport->isOpen();
 }
 
-void ThriftFileStore::configure(pStoreConf configuration, pStoreConf parent) {
-  FileStoreBase::configure(configuration, parent);
+void ThriftFileStore::configure(pStoreConf configuration) {
+  FileStoreBase::configure(configuration);
   configuration->getUnsigned("flush_frequency_ms", flushFrequencyMs);
   configuration->getUnsigned("msg_buffer_size", msgBufferSize);
   configuration->getUnsigned("use_simple_file", useSimpleFile);
@@ -1138,14 +1033,8 @@ bool ThriftFileStore::openInternal(bool incrementFilename, struct tm* current_ti
     localtime_r(&rawtime, &timeinfo);
     current_time = &timeinfo;
   }
-  int suffix;
-  try {
-    suffix = findNewestFile(makeBaseFilename(current_time));
-  } catch(const std::exception& e) {
-    LOG_OPER("Exception < %s > in ThriftFileStore::openInternal",
-      e.what());
-    return false;
-  }
+
+  int suffix = findNewestFile(makeBaseFilename(current_time));
 
   if (incrementFilename) {
     ++suffix;
@@ -1197,8 +1086,7 @@ bool ThriftFileStore::openInternal(bool incrementFilename, struct tm* current_ti
       }
     }
 
-    LOG_OPER("[%s] Opened file <%s> for writing",
-        categoryHandled.c_str(), filename.c_str());
+    LOG_OPER("[%s] Opened file <%s> for writing", categoryHandled.c_str(), filename.c_str());
 
     struct stat st;
     if (stat(filename.c_str(), &st) == 0) {
@@ -1209,9 +1097,8 @@ bool ThriftFileStore::openInternal(bool incrementFilename, struct tm* current_ti
     currentFilename = filename;
     eventsWritten = 0;
     setStatus("");
-  } catch (const TException& te) {
-    LOG_OPER("[%s] Failed to open file <%s> for writing: %s\n",
-        categoryHandled.c_str(), filename.c_str(), te.what());
+  } catch (TException te) {
+    LOG_OPER("[%s] Failed to open file <%s> for writing: %s\n", categoryHandled.c_str(), filename.c_str(), te.what());
     setStatus("File open error");
     return false;
   }
@@ -1230,7 +1117,7 @@ bool ThriftFileStore::openInternal(bool incrementFilename, struct tm* current_ti
 bool ThriftFileStore::createFileDirectory () {
   try {
     boost::filesystem::create_directories(filePath);
-  } catch(const std::exception& e) {
+  }catch(std::exception const& e) {
     LOG_OPER("Exception < %s > in ThriftFileStore::createFileDirectory for path %s",
       e.what(),filePath.c_str());
     return false;
@@ -1238,25 +1125,17 @@ bool ThriftFileStore::createFileDirectory () {
   return true;
 }
 
-BufferStore::BufferStore(StoreQueue* storeq,
-                        const string& category,
-                        bool multi_category)
-  : Store(storeq, category, "buffer", multi_category),
+BufferStore::BufferStore(const string& category, bool multi_category)
+  : Store(category, "buffer", multi_category),
+    maxQueueLength(DEFAULT_BUFFERSTORE_MAX_QUEUE_LENGTH),
     bufferSendRate(DEFAULT_BUFFERSTORE_SEND_RATE),
     avgRetryInterval(DEFAULT_BUFFERSTORE_AVG_RETRY_INTERVAL),
     retryIntervalRange(DEFAULT_BUFFERSTORE_RETRY_INTERVAL_RANGE),
     replayBuffer(true),
-    adaptiveBackoff(false),
-    minRetryInterval(DEFAULT_MIN_RETRY),
-    maxRetryInterval(DEFAULT_MAX_RETRY),
-    maxRandomOffset(DEFAULT_RANDOM_OFFSET_RANGE),
-    retryInterval(DEFAULT_MIN_RETRY),
-    numContSuccess(0),
-    state(DISCONNECTED),
-    flushStreaming(false),
-    maxByPassRatio(DEFAULT_BUFFERSTORE_BYPASS_MAXQSIZE_RATIO) {
+    state(DISCONNECTED) {
 
-    lastOpenAttempt = time(NULL);
+  lastWriteTime = lastOpenAttempt = time(NULL);
+  retryInterval = getNewRetryInterval();
 
   // we can't open the client conection until we get configured
 }
@@ -1265,70 +1144,24 @@ BufferStore::~BufferStore() {
 
 }
 
-void BufferStore::configure(pStoreConf configuration, pStoreConf parent) {
-  Store::configure(configuration, parent);
+void BufferStore::configure(pStoreConf configuration) {
 
   // Constructor defaults are fine if these don't exist
+  configuration->getUnsigned("max_queue_length", (unsigned long&) maxQueueLength);
   configuration->getUnsigned("buffer_send_rate", (unsigned long&) bufferSendRate);
-
-  // Used for linear backoff case
-  configuration->getUnsigned("retry_interval",
-                             (unsigned long&) avgRetryInterval);
-  configuration->getUnsigned("retry_interval_range",
-                             (unsigned long&) retryIntervalRange);
-
-  // Used in case of adaptive backoff
-  // max_random_offset should be some fraction of max_retry_interval
-  // 20% of max_retry_interval should be a decent value
-  // if you are using max_random_offset > max_retry_interval you should
-  // probably not be using adaptive backoff and using retry_interval and
-  // retry_interval_range parameters to do linear backoff instead
-  configuration->getUnsigned("min_retry_interval",
-                             (unsigned long&) minRetryInterval);
-  configuration->getUnsigned("max_retry_interval",
-                             (unsigned long&) maxRetryInterval);
-  configuration->getUnsigned("max_random_offset",
-                             (unsigned long&) maxRandomOffset);
-  if (maxRandomOffset > maxRetryInterval) {
-    LOG_OPER(" Warning max_random_offset > max_retry_interval look at using adaptive_backoff=no instead setting max_random_offset to max_retry_interval");
-    maxRandomOffset = maxRetryInterval;
-  }
+  configuration->getUnsigned("retry_interval", (unsigned long&) avgRetryInterval);
+  configuration->getUnsigned("retry_interval_range", (unsigned long&) retryIntervalRange);
 
   string tmp;
   if (configuration->getString("replay_buffer", tmp) && tmp != "yes") {
     replayBuffer = false;
   }
 
-  if (configuration->getString("flush_streaming", tmp) && tmp == "yes") {
-    flushStreaming = true;
-  }
-
-  if (configuration->getString("buffer_bypass_max_ratio", tmp)) {
-    double d = strtod(tmp.c_str(), NULL);
-    if (d > 0 && d <= 1) {
-      maxByPassRatio = d;
-    } else {
-      LOG_OPER("[%s] Bad config - buffer_bypass_max_ratio <%s> range is (0, 1]",
-          categoryHandled.c_str(), tmp.c_str());
-    }
-  }
-
-  if (configuration->getString("adaptive_backoff", tmp) && tmp == "yes") {
-    adaptiveBackoff = true;
-  }
-
   if (retryIntervalRange > avgRetryInterval) {
     LOG_OPER("[%s] Bad config - retry_interval_range must be less than retry_interval. Using <%d> as range instead of <%d>",
-             categoryHandled.c_str(), (int)avgRetryInterval,
-             (int)retryIntervalRange);
+             categoryHandled.c_str(), (int)avgRetryInterval, (int)retryIntervalRange);
     retryIntervalRange = avgRetryInterval;
   }
-  if (minRetryInterval > maxRetryInterval) {
-    LOG_OPER("[%s] Bad config - min_retry_interval must be less than max_retry_interval. Using <%d> and  <%d>, the default values instead",
-             categoryHandled.c_str(), DEFAULT_MIN_RETRY, DEFAULT_MAX_RETRY );
-    minRetryInterval = DEFAULT_MIN_RETRY;
-    maxRetryInterval = DEFAULT_MAX_RETRY;
-  }
 
   pStoreConf secondary_store_conf;
   if (!configuration->getStore("secondary", secondary_store_conf)) {
@@ -1343,9 +1176,9 @@ void BufferStore::configure(pStoreConf configuration, pStoreConf parent) {
       cout << msg << endl;
     } else {
       // If replayBuffer is true, then we need to create a readable store
-      secondaryStore = createStore(storeQueue, type, categoryHandled,
-                                   replayBuffer, multiCategory);
-      secondaryStore->configure(secondary_store_conf, storeConf);
+      secondaryStore = createStore(type, categoryHandled, replayBuffer,
+                                   multiCategory);
+      secondaryStore->configure(secondary_store_conf);
     }
   }
 
@@ -1367,21 +1200,18 @@ void BufferStore::configure(pStoreConf configuration, pStoreConf parent) {
       string msg("Bad config - buffer primary store cannot be multistore");
       setStatus(msg);
     } else {
-      primaryStore = createStore(storeQueue, type, categoryHandled, false,
-                                  multiCategory);
-      primaryStore->configure(primary_store_conf, storeConf);
+      primaryStore = createStore(type, categoryHandled, false, multiCategory);
+      primaryStore->configure(primary_store_conf);
     }
   }
 
   // If the config is bad we'll still try to write the data to a
   // default location on local disk.
   if (!secondaryStore) {
-    secondaryStore = createStore(storeQueue, "file", categoryHandled, true,
-                                multiCategory);
+    secondaryStore = createStore("file", categoryHandled, true, multiCategory);
   }
   if (!primaryStore) {
-    primaryStore = createStore(storeQueue, "file", categoryHandled, false,
-                               multiCategory);
+    primaryStore = createStore("file", categoryHandled, false, multiCategory);
   }
 }
 
@@ -1431,19 +1261,14 @@ void BufferStore::flush() {
 }
 
 shared_ptr<Store> BufferStore::copy(const std::string &category) {
-  BufferStore *store = new BufferStore(storeQueue, category, multiCategory);
+  BufferStore *store = new BufferStore(category, multiCategory);
   shared_ptr<Store> copied = shared_ptr<Store>(store);
 
+  store->maxQueueLength = maxQueueLength;
   store->bufferSendRate = bufferSendRate;
   store->avgRetryInterval = avgRetryInterval;
   store->retryIntervalRange = retryIntervalRange;
-  store->retryInterval = retryInterval;
-  store->numContSuccess = numContSuccess;
   store->replayBuffer = replayBuffer;
-  store->minRetryInterval = minRetryInterval;
-  store->maxRetryInterval = maxRetryInterval;
-  store->maxRandomOffset = maxRandomOffset;
-  store->adaptiveBackoff = adaptiveBackoff;
 
   store->primaryStore = primaryStore->copy(category);
   store->secondaryStore = secondaryStore->copy(category);
@@ -1451,12 +1276,17 @@ shared_ptr<Store> BufferStore::copy(const std::string &category) {
 }
 
 bool BufferStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages) {
+  lastWriteTime = time(NULL);
 
-  if (state == STREAMING || (flushStreaming && state == SENDING_BUFFER)) {
+  // If the queue is really long it's probably because the primary store isn't moving
+  // fast enough and is backing up, in which case it's best to give up on it for now.
+  if (state == STREAMING && messages->size() > maxQueueLength) {
+    LOG_OPER("[%s] BufferStore queue backing up, switching to secondary store (%u messages)", categoryHandled.c_str(), (unsigned)messages->size());
+    changeState(DISCONNECTED);
+  }
+
+  if (state == STREAMING) {
     if (primaryStore->handleMessages(messages)) {
-      if (adaptiveBackoff) {
-        setNewRetryInterval(true);
-      }
       return true;
     } else {
       changeState(DISCONNECTED);
@@ -1501,9 +1331,11 @@ void BufferStore::changeState(buffer_state_t new_state) {
     // Do not set status here as it is possible to be in this frequently.
     // Whatever caused us to enter this state should have either set status
     // or chosen not to set status.
-    g_Handler->incCounter(categoryHandled, "retries");
-    setNewRetryInterval(false);
+    g_Handler->incrementCounter("retries");
     lastOpenAttempt = time(NULL);
+    retryInterval = getNewRetryInterval();
+    LOG_OPER("[%s] choosing new retry interval <%d> seconds", categoryHandled.c_str(),
+             (int)retryInterval);
     if (!secondaryStore->isOpen()) {
       secondaryStore->open();
     }
@@ -1517,8 +1349,7 @@ void BufferStore::changeState(buffer_state_t new_state) {
     break;
   }
 
-  LOG_OPER("[%s] Changing state from <%s> to <%s>",
-      categoryHandled.c_str(), stateAsString(state), stateAsString(new_state));
+  LOG_OPER("[%s] Changing state from <%s> to <%s>", categoryHandled.c_str(), stateAsString(state), stateAsString(new_state));
   state = new_state;
 }
 
@@ -1533,7 +1364,9 @@ void BufferStore::periodicCheck() {
   localtime_r(&now, &nowinfo);
 
   if (state == DISCONNECTED) {
+
     if (now - lastOpenAttempt > retryInterval) {
+
       if (primaryStore->open()) {
         // Success.  Check if we need to send buffers from secondary to primary
         if (replayBuffer) {
@@ -1548,162 +1381,71 @@ void BufferStore::periodicCheck() {
     }
   }
 
-  // send data in case of backup
   if (state == SENDING_BUFFER) {
-    // if queue size is getting large return so that there is time to forward
-    // incoming messages directly to the primary store without buffering to
-    // secondary store.
-    if (flushStreaming) {
-      uint64_t qsize = storeQueue->getSize();
-      if(qsize >=
-          maxByPassRatio * g_Handler->getMaxQueueSize()) {
-        return;
-      }
-    }
 
     // Read a group of messages from the secondary store and send them to
     // the primary store. Note that the primary store could tell us to try
     // again later, so this isn't very efficient if it reads too many
     // messages at once. (if the secondary store is a file, the number of
     // messages read is controlled by the max file size)
-    // parameter max_size for filestores in the configuration
     unsigned sent = 0;
-    try {
-      for (sent = 0; sent < bufferSendRate; ++sent) {
-        boost::shared_ptr<logentry_vector_t> messages(new logentry_vector_t);
-        // Reads come complete buffered file
-        // this file size is controlled by max_size in the configuration
-        if (secondaryStore->readOldest(messages, &nowinfo)) {
-
-          unsigned long size = messages->size();
-          if (size) {
-            if (primaryStore->handleMessages(messages)) {
-              secondaryStore->deleteOldest(&nowinfo);
-              if (adaptiveBackoff) {
-                setNewRetryInterval(true);
-              }
-            } else {
-
-              if (messages->size() != size) {
-                // We were only able to process some, but not all of this batch
-                // of messages.  Replace this batch of messages with
-                // just the messages that were not processed.
-                LOG_OPER("[%s] buffer store primary store processed %lu/%lu messages",
-                    categoryHandled.c_str(), size - messages->size(), size);
-
-                // Put back un-handled messages
-                if (!secondaryStore->replaceOldest(messages, &nowinfo)) {
-                  // Nothing we can do but try to remove oldest messages and
-                  // report a loss
-                  LOG_OPER("[%s] buffer store secondary store lost %lu messages",
-                      categoryHandled.c_str(), messages->size());
-                  g_Handler->incCounter(categoryHandled, "lost", messages->size());
-                  secondaryStore->deleteOldest(&nowinfo);
-                }
+    for (sent = 0; sent < bufferSendRate; ++sent) {
+      boost::shared_ptr<logentry_vector_t> messages(new logentry_vector_t);
+      if (secondaryStore->readOldest(messages, &nowinfo)) {
+        lastWriteTime = time(NULL);
+
+        unsigned long size = messages->size();
+        if (size) {
+          if (primaryStore->handleMessages(messages)) {
+            secondaryStore->deleteOldest(&nowinfo);
+          } else {
+
+            if (messages->size() != size) {
+              // We were only able to process some, but not all of this batch
+              // of messages.  Replace this batch of messages with just the messages
+              // that were not processed.
+              LOG_OPER("[%s] buffer store primary store processed %lu/%lu messages",
+                       categoryHandled.c_str(), size - messages->size(), size);
+
+              // Put back un-handled messages
+              if (!secondaryStore->replaceOldest(messages, &nowinfo)) {
+                // Nothing we can do but try to remove oldest messages and report a loss
+                LOG_OPER("[%s] buffer store secondary store lost %lu messages",
+                         categoryHandled.c_str(), messages->size());
+                g_Handler->incrementCounter("lost", messages->size());
+                secondaryStore->deleteOldest(&nowinfo);
               }
-              changeState(DISCONNECTED);
-              break;
             }
-          }  else {
-            // else it's valid for read to not find anything but not error
-            secondaryStore->deleteOldest(&nowinfo);
+
+            changeState(DISCONNECTED);
+            break;
           }
-        } else {
-          // This is bad news. We'll stay in the sending state
-          // and keep trying to read.
-          setStatus("Failed to read from secondary store");
-          LOG_OPER("[%s] WARNING: buffer store can't read from secondary store",
-              categoryHandled.c_str());
-          break;
+        }  else {
+          // else it's valid for read to not find anything but not error
+          secondaryStore->deleteOldest(&nowinfo);
         }
+      } else {
+        // This is bad news. We'll stay in the sending state and keep trying to read.
+        setStatus("Failed to read from secondary store");
+        LOG_OPER("[%s] WARNING: buffer store can't read from secondary store", categoryHandled.c_str());
+        break;
+      }
 
-        if (secondaryStore->empty(&nowinfo)) {
-          LOG_OPER("[%s] No more buffer files to send, switching to streaming mode",
-              categoryHandled.c_str());
-          changeState(STREAMING);
+      if (secondaryStore->empty(&nowinfo)) {
+        LOG_OPER("[%s] No more buffer files to send, switching to streaming mode", categoryHandled.c_str());
+        changeState(STREAMING);
 
-          break;
-        }
+        primaryStore->flush();
+        break;
       }
-    } catch(const std::exception& e) {
-      LOG_OPER("[%s] Failed in secondary to primary transfer ",
-          categoryHandled.c_str());
-      LOG_OPER("Exception: %s", e.what());
-      setStatus("bufferstore sending_buffer failure");
-      changeState(DISCONNECTED);
     }
   }// if state == SENDING_BUFFER
 }
 
-/*
- * This functions sets a new time interval after which the buffer store
- * will retry connecting to primary. There are two modes based on the
- * config parameter 'adaptive_backoff'.
- *
- *
- * When adaptive_backoff=yes this function uses an Additive Increase and
- * Multiplicative Decrease strategy which is commonly used in networking
- * protocols for congestion avoidance, while achieving fairness and good
- * throughput for multiple senders.
- * The algorithm works as follows. Whenever the buffer store is able to
- * achieve CONT_SUCCESS_THRESHOLD continuous successful sends to the
- * primary store its retry interval is decreased by ADD_DEC_FACTOR.
- * Whenever the buffer store fails to send to primary its retry interval
- * is increased by multiplying a MULT_INC_FACTOR to it. To avoid thundering
- * herds problems a random offset is added to this new retry interval
- * controlled by 'max_random_offset' config parameter.
- * The range of the retry interval is controlled by config parameters
- * 'min_retry_interval' and 'max_retry_interval'.
- * Currently CONT_SUCCESS_THRESHOLD, ADD_DEC_FACTOR and MULT_INC_FACTOR
- * are not config parameters. This can be done later if need be.
- *
- *
- * In case adaptive_backoff=no, the new retry interval is calculated
- * using the config parameters 'avg_retry_interval' and
- * 'retry_interval_range'
- */
-void BufferStore::setNewRetryInterval(bool success) {
-
-  if (adaptiveBackoff) {
-    time_t prevRetryInterval = retryInterval;
-    if (success) {
-      numContSuccess++;
-      if (numContSuccess >= CONT_SUCCESS_THRESHOLD) {
-        if (retryInterval > ADD_DEC_FACTOR) {
-          retryInterval -= ADD_DEC_FACTOR;
-        }
-        else {
-          retryInterval = minRetryInterval;
-        }
-        if (retryInterval < minRetryInterval) {
-          retryInterval = minRetryInterval;
-        }
-        numContSuccess = 0;
-      }
-      else {
-        return;
-      }
-    }
-    else {
-      retryInterval = static_cast <time_t> (retryInterval*MULT_INC_FACTOR);
-      retryInterval += (rand() % maxRandomOffset);
-      if (retryInterval > maxRetryInterval) {
-        retryInterval = maxRetryInterval;
-      }
-      numContSuccess = 0;
-    }
-    // prevent unnecessary prints
-    if (prevRetryInterval == retryInterval) {
-      return;
-    }
-  }
-  else {
-    retryInterval = avgRetryInterval - retryIntervalRange/2
-                    + rand() % retryIntervalRange;
-  }
-  LOG_OPER("[%s] choosing new retry interval <%lu> seconds",
-           categoryHandled.c_str(),
-           (unsigned long) retryInterval);
+
+time_t BufferStore::getNewRetryInterval() {
+  time_t interval = avgRetryInterval - retryIntervalRange/2 + rand() % retryIntervalRange;
+  return interval;
 }
 
 const char* BufferStore::stateAsString(buffer_state_t state) {
@@ -1735,18 +1477,14 @@ std::string BufferStore::getStatus() {
 }
 
 
-NetworkStore::NetworkStore(StoreQueue* storeq,
-                          const string& category,
-                          bool multi_category)
-  : Store(storeq, category, "network", multi_category),
+NetworkStore::NetworkStore(const string& category, bool multi_category)
+  : Store(category, "network", multi_category),
     useConnPool(false),
-    serviceBased(false),
+    smcBased(false),
     remotePort(0),
     serviceCacheTimeout(DEFAULT_NETWORKSTORE_CACHE_TIMEOUT),
-    ignoreNetworkError(false),
-    configmod(NULL),
-    opened(false),
-    lastServiceCheck(0) {
+    lastServiceCheck(0),
+    opened(false) {
   // we can't open the connection until we get configured
 
   // the bool for opened ensures that we don't make duplicate
@@ -1758,18 +1496,17 @@ NetworkStore::~NetworkStore() {
   close();
 }
 
-void NetworkStore::configure(pStoreConf configuration, pStoreConf parent) {
-  Store::configure(configuration, parent);
+void NetworkStore::configure(pStoreConf configuration) {
   // Error checking is done on open()
-  // service takes precedence over host + port
-  if (configuration->getString("smc_service", serviceName)) {
-    serviceBased = true;
+  // smc takes precedence over host + port
+  if (configuration->getString("smc_service", smcService)) {
+    smcBased = true;
 
     // Constructor defaults are fine if these don't exist
     configuration->getString("service_options", serviceOptions);
     configuration->getUnsigned("service_cache_timeout", serviceCacheTimeout);
   } else {
-    serviceBased = false;
+    smcBased = false;
     configuration->getString("remote_host", remoteHost);
     configuration->getUnsigned("remote_port", remotePort);
   }
@@ -1784,68 +1521,11 @@ void NetworkStore::configure(pStoreConf configuration, pStoreConf parent) {
       useConnPool = true;
     }
   }
-  if (configuration->getString("ignore_network_error", temp)) {
-    if (0 == temp.compare("yes")) {
-      ignoreNetworkError = true;
-    }
-  }
-
-  // if this network store dynamic configured?
-  // get network dynamic updater parameters
-  string dynamicType;
-  if (configuration->getString("dynamic_config_type", dynamicType)) {
-    // get dynamic config module
-    configmod = getNetworkDynamicConfigMod(dynamicType.c_str());
-    if (configmod) {
-      if (!configmod->isConfigValidFunc(categoryHandled, configuration.get())) {
-        LOG_OPER("[%s] dynamic network configuration is not valid.",
-                categoryHandled.c_str());
-        configmod = NULL;
-      } else {
-        // set remote host port
-        string host;
-        uint32_t port;
-        if (configmod->getHostFunc(categoryHandled, storeConf.get(), host, port)) {
-          remoteHost = host;
-          remotePort = port;
-          LOG_OPER("[%s] dynamic configred network store destination configured:<%s:%lu>",
-            categoryHandled.c_str(), remoteHost.c_str(), remotePort);
-        }
-      }
-    } else {
-      LOG_OPER("[%s] dynamic network configuration is not valid. Unable to find network dynamic configuration module with name <%s>",
-                categoryHandled.c_str(), dynamicType.c_str());
-    }
-  }
-}
-
-void NetworkStore::periodicCheck() {
-  if (configmod) {
-    // get the network updater type
-    string host;
-    uint32_t port;
-    bool success = configmod->getHostFunc(categoryHandled, storeConf.get(), host, port);
-    if (success && (host != remoteHost || port != remotePort)) {
-      // if it is different from the current configuration
-      // then close and open again
-      LOG_OPER("[%s] dynamic configred network store destination changed. old value:<%s:%lu>, new value:<%s:%lu>",
-               categoryHandled.c_str(), remoteHost.c_str(), remotePort,
-               host.c_str(), (long unsigned)port);
-      remoteHost = host;
-      remotePort = port;
-      close();
-    }
-  }
 }
 
 bool NetworkStore::open() {
-  if (isOpen()) {
-    /* re-opening an already open NetworkStore can be bad. For example,
-     * it can lead to bad reference counting on g_connpool connections
-     */
-    return (true);
-  }
-  if (serviceBased) {
+
+  if (smcBased) {
     bool success = true;
     time_t now = time(NULL);
 
@@ -1853,58 +1533,57 @@ bool NetworkStore::open() {
     if (lastServiceCheck <= (time_t) (now - serviceCacheTimeout)) {
       lastServiceCheck = now;
 
-      success = scribe::network_config::getService(serviceName, serviceOptions,
-                                                   servers);
+      success =
+        network_config::getService(smcService, serviceOptions, servers);
     }
 
     // Cannot open if we couldn't find any servers
     if (!success || servers.empty()) {
-      LOG_OPER("[%s] Failed to get servers from service", categoryHandled.c_str());
-      setStatus("Could not get list of servers from service");
+      LOG_OPER("[%s] Failed to get servers from smc", categoryHandled.c_str());
+      setStatus("Could not get list of servers from smc");
       return false;
     }
 
     if (useConnPool) {
-      opened = g_connPool.open(serviceName, servers, static_cast<int>(timeout));
+      opened = g_connPool.open(smcService, servers, static_cast<int>(timeout));
     } else {
-      if (unpooledConn != NULL) {
-        LOG_OPER("Logic error: NetworkStore::open unpooledConn is not NULL"
-            " service = %s", serviceName.c_str());
-      }
-      unpooledConn = shared_ptr<scribeConn>(new scribeConn(serviceName,
-            servers, static_cast<int>(timeout)));
-      opened = unpooledConn->open();
-      if (!opened) {
-        unpooledConn.reset();
+      // only open unpooled connection if not already open
+      if (unpooledConn == NULL) {
+        unpooledConn = shared_ptr<scribeConn>(new scribeConn(smcService, servers, static_cast<int>(timeout)));
+        opened = unpooledConn->open();
+      } else {
+        opened = unpooledConn->isOpen();
+        if (!opened) {
+          opened = unpooledConn->open();
+        }
       }
     }
 
-  } else if (remotePort <= 0 || remoteHost.empty()) {
-    LOG_OPER("[%s] Bad config - won't attempt to connect to <%s:%lu>",
-        categoryHandled.c_str(), remoteHost.c_str(), remotePort);
+  } else if (remotePort <= 0 ||
+             remoteHost.empty()) {
+    LOG_OPER("[%s] Bad config - won't attempt to connect to <%s:%lu>", categoryHandled.c_str(), remoteHost.c_str(), remotePort);
     setStatus("Bad config - invalid location for remote server");
     return false;
+
   } else {
     if (useConnPool) {
-      opened = g_connPool.open(remoteHost, remotePort,
-          static_cast<int>(timeout));
+      opened = g_connPool.open(remoteHost, remotePort, static_cast<int>(timeout));
     } else {
       // only open unpooled connection if not already open
-      if (unpooledConn != NULL) {
-        LOG_OPER("Logic error: NetworkStore::open unpooledConn is not NULL"
-            " %s:%lu", remoteHost.c_str(), remotePort);
-      }
-      unpooledConn = shared_ptr<scribeConn>(new scribeConn(remoteHost,
-          remotePort, static_cast<int>(timeout)));
-      opened = unpooledConn->open();
-      if (!opened) {
-        unpooledConn.reset();
+      if (unpooledConn == NULL) {
+        unpooledConn = shared_ptr<scribeConn>(new scribeConn(remoteHost, remotePort, static_cast<int>(timeout)));
+        opened = unpooledConn->open();
+      } else {
+        opened = unpooledConn->isOpen();
+        if (!opened) {
+          opened = unpooledConn->open();
+        }
       }
     }
   }
 
-  if (opened || ignoreNetworkError) {
-    // clear status on success or if we should not signal error here
+
+  if (opened) {
     setStatus("");
   } else {
     setStatus("Failed to connect");
@@ -1918,8 +1597,8 @@ void NetworkStore::close() {
   }
   opened = false;
   if (useConnPool) {
-    if (serviceBased) {
-      g_connPool.close(serviceName);
+    if (smcBased) {
+      g_connPool.close(smcService);
     } else {
       g_connPool.close(remoteHost, remotePort);
     }
@@ -1927,7 +1606,6 @@ void NetworkStore::close() {
     if (unpooledConn != NULL) {
       unpooledConn->close();
     }
-    unpooledConn.reset();
   }
 }
 
@@ -1936,74 +1614,45 @@ bool NetworkStore::isOpen() {
 }
 
 shared_ptr<Store> NetworkStore::copy(const std::string &category) {
-  NetworkStore *store = new NetworkStore(storeQueue, category, multiCategory);
+  NetworkStore *store = new NetworkStore(category, multiCategory);
   shared_ptr<Store> copied = shared_ptr<Store>(store);
 
   store->useConnPool = useConnPool;
-  store->serviceBased = serviceBased;
+  store->smcBased = smcBased;
   store->timeout = timeout;
   store->remoteHost = remoteHost;
   store->remotePort = remotePort;
-  store->serviceName = serviceName;
+  store->smcService = smcService;
 
   return copied;
 }
 
-
-// If the size of messages is greater than a threshold
-// first try sending an empty vector to catch dfqs
-bool
-NetworkStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages) {
-  int ret;
-
+bool NetworkStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages) {
   if (!isOpen()) {
-    if (!open()) {
-    LOG_OPER("[%s] Could not open NetworkStore in handleMessages",
-             categoryHandled.c_str());
+    LOG_OPER("[%s] Logic error: NetworkStore::handleMessages called on closed store", categoryHandled.c_str());
     return false;
-    }
-  }
-
-  bool tryDummySend = shouldSendDummy(messages);
-  boost::shared_ptr<logentry_vector_t> dummymessages(new logentry_vector_t);
-
-  if (useConnPool) {
-    if (serviceBased) {
-      if (!tryDummySend ||
-          ((ret = g_connPool.send(serviceName, dummymessages)) == CONN_OK)) {
-        ret = g_connPool.send(serviceName, messages);
-      }
+  } else if (useConnPool) {
+    if (smcBased) {
+      return g_connPool.send(smcService, messages);
     } else {
-      if (!tryDummySend ||
-          (ret = g_connPool.send(remoteHost, remotePort, dummymessages)) ==
-          CONN_OK) {
-        ret = g_connPool.send(remoteHost, remotePort, messages);
-      }
-    }
-  } else if (unpooledConn) {
-    if (!tryDummySend ||
-        ((ret = unpooledConn->send(dummymessages)) == CONN_OK)) {
-      ret = unpooledConn->send(messages);
+      return g_connPool.send(remoteHost, remotePort, messages);
     }
   } else {
-    ret = CONN_FATAL;
-    LOG_OPER("[%s] Logic error: NetworkStore::handleMessages unpooledConn "
-        "is NULL", categoryHandled.c_str());
-  }
-  if (ret == CONN_FATAL) {
-    close();
+    if (unpooledConn) {
+      return unpooledConn->send(messages);
+    } else {
+      LOG_OPER("[%s] Logic error: NetworkStore::handleMessages unpooledConn is NULL", categoryHandled.c_str());
+      return false;
+    }
   }
-  return (ret == CONN_OK);
 }
 
 void NetworkStore::flush() {
   // Nothing to do
 }
 
-BucketStore::BucketStore(StoreQueue* storeq,
-                        const string& category,
-                        bool multi_category)
-  : Store(storeq, category, "bucket", multi_category),
+BucketStore::BucketStore(const string& category, bool multi_category)
+  : Store(category, "bucket", multi_category),
     bucketType(context_log),
     delimiter(DEFAULT_BUCKETSTORE_DELIMITER),
     removeKey(false),
@@ -2018,7 +1667,7 @@ BucketStore::~BucketStore() {
 
 // Given a single bucket definition, create multiple buckets
 void BucketStore::createBucketsFromBucket(pStoreConf configuration,
-    pStoreConf bucket_conf) {
+					  pStoreConf bucket_conf) {
   string error_msg, bucket_subdir, type, path, failure_bucket;
   bool needs_bucket_subdir = false;
   unsigned long bucket_offset = 0;
@@ -2063,7 +1712,7 @@ void BucketStore::createBucketsFromBucket(pStoreConf configuration,
   for (unsigned int i = 0; i <= numBuckets; ++i) {
 
     shared_ptr<Store> newstore =
-      createStore(storeQueue, type, categoryHandled, false, multiCategory);
+      createStore(type, categoryHandled, false, multiCategory);
 
     if (!newstore) {
       error_msg = "can't create store of type: ";
@@ -2087,7 +1736,7 @@ void BucketStore::createBucketsFromBucket(pStoreConf configuration,
     }
 
     buckets.push_back(newstore);
-    newstore->configure(bucket_conf, storeConf);
+    newstore->configure(bucket_conf);
   }
 
   return;
@@ -2108,18 +1757,21 @@ void BucketStore::createBuckets(pStoreConf configuration) {
   unsigned long i;
 
   if (configuration->getString("bucket_subdir", tmp_string)) {
-    error_msg = "cannot have bucket_subdir when defining multiple buckets";
-    goto handle_error;
+    error_msg =
+      "cannot have bucket_subdir when defining multiple buckets";
+      goto handle_error;
   }
 
   if (configuration->getString("bucket_offset", tmp_string)) {
-    error_msg = "cannot have bucket_offset when defining multiple buckets";
-    goto handle_error;
+    error_msg =
+      "cannot have bucket_offset when defining multiple buckets";
+      goto handle_error;
   }
 
   if (configuration->getString("failure_bucket", tmp_string)) {
-    error_msg = "cannot have failure_bucket when defining multiple buckets";
-    goto handle_error;
+    error_msg =
+      "cannot have failure_bucket when defining multiple buckets";
+      goto handle_error;
   }
 
   // Configure stores named 'bucket0, bucket1, bucket2, ... bucket{numBuckets}
@@ -2132,26 +1784,22 @@ void BucketStore::createBuckets(pStoreConf configuration) {
     bucket_name = ss.str();
 
     if (!configuration->getStore(bucket_name, bucket_conf)) {
-      error_msg = "could not find bucket definition for " + bucket_name;
+      error_msg = "could not find bucket definition for " +
+	bucket_name;
       goto handle_error;
     }
 
     if (!bucket_conf->getString("type", type)) {
-      error_msg = "store contained in a bucket store must have a type";
+      error_msg =
+	"store contained in a bucket store must have a type";
       goto handle_error;
     }
 
     shared_ptr<Store> bucket =
-      createStore(storeQueue, type, categoryHandled, false, multiCategory);
+      createStore(type, categoryHandled, false, multiCategory);
 
     buckets.push_back(bucket);
-    //add bucket id configuration
-    bucket_conf->setUnsigned("bucket_id", i);
-    bucket_conf->setUnsigned("network::bucket_id", i);
-    bucket_conf->setUnsigned("file::bucket_id", i);
-    bucket_conf->setUnsigned("thriftfile::bucket_id", i);
-    bucket_conf->setUnsigned("buffer::bucket_id", i);
-    bucket->configure(bucket_conf, storeConf);
+    bucket->configure(bucket_conf);
   }
 
   // Check if an extra bucket is defined
@@ -2203,8 +1851,7 @@ handle_error:
    *   </bucket>
    * </store>
    */
-void BucketStore::configure(pStoreConf configuration, pStoreConf parent) {
-  Store::configure(configuration, parent);
+void BucketStore::configure(pStoreConf configuration) {
 
   string error_msg, bucketizer_str, remove_key_str;
   unsigned long delim_long = 0;
@@ -2340,24 +1987,16 @@ string BucketStore::getStatus() {
   return retval;
 }
 
-// Call periodicCheck on all containing stores
 void BucketStore::periodicCheck() {
-  // Call periodic check on all bucket stores in a random order
-  uint32_t sz = buckets.size();
-  vector<uint32_t> storeIndex(sz);
-  for (uint32_t i = 0; i < sz; ++i) {
-    storeIndex[i] = i;
-  }
-  random_shuffle(storeIndex.begin(), storeIndex.end());
-
-  for (uint32_t i = 0; i < sz; ++i) {
-    uint32_t idx = storeIndex[i];
-    buckets[idx]->periodicCheck();
+  for (std::vector<shared_ptr<Store> >::iterator iter = buckets.begin();
+       iter != buckets.end();
+       ++iter) {
+    (*iter)->periodicCheck();
   }
 }
 
 shared_ptr<Store> BucketStore::copy(const std::string &category) {
-  BucketStore *store = new BucketStore(storeQueue, category, multiCategory);
+  BucketStore *store = new BucketStore(category, multiCategory);
   shared_ptr<Store> copied = shared_ptr<Store>(store);
 
   store->numBuckets = numBuckets;
@@ -2373,12 +2012,6 @@ shared_ptr<Store> BucketStore::copy(const std::string &category) {
   return copied;
 }
 
-/*
- * Bucketize <messages> and try to send to each contained bucket store
- * At the end of the function <messages> will contain all the messages that
- * could not be processed
- * Returns true if all messages were successfully sent, false otherwise.
- */
 bool BucketStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages) {
   bool success = true;
 
@@ -2447,7 +2080,6 @@ bool BucketStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages)
   return success;
 }
 
-// Return the bucket number a message must be put into
 unsigned long BucketStore::bucketize(const std::string& message) {
 
   string::size_type length = message.length();
@@ -2475,7 +2107,7 @@ unsigned long BucketStore::bucketize(const std::string& message) {
     if (numBuckets == 0) {
       return 0;
     } else {
-      return (scribe::integerhash::hash32(id) % numBuckets) + 1;
+      return (integerhash::hash32(id) % numBuckets) + 1;
     }
   } else if (bucketType == random) {
     // return any random bucket
@@ -2515,7 +2147,7 @@ unsigned long BucketStore::bucketize(const std::string& message) {
         case key_hash:
         default:
           // Hashing by default.
-          return (scribe::strhash::hash32(key.c_str()) % numBuckets) + 1;
+          return (strhash::hash32(key.c_str()) % numBuckets) + 1;
           break;
       }
     }
@@ -2534,18 +2166,135 @@ string BucketStore::getMessageWithoutKey(const std::string& message) {
   return message.substr(pos+1);
 }
 
+// RedisStore
+// ############################################################################
+
+RedisStore::RedisStore(const std::string& category, bool multi_category)
+  : Store(category, "null", multi_category),
+  redisHost("localhost"),
+  redisPort(6379)
+{}
+
+RedisStore::~RedisStore() {
+}
+
+boost::shared_ptr<Store> RedisStore::copy(const std::string &category) {
+  RedisStore *store = new RedisStore(category, multiCategory);
+  shared_ptr<Store> copied = shared_ptr<Store>(store);
+  return copied;
+}
+
+bool RedisStore::open() {
+  struct timeval timeout = { 1, 500000 }; // 1.5 seconds
+  try {
+      c = redisConnectWithTimeout(redisHost.c_str(), redisPort, timeout);
+      if (c->err) {
+        printf("Could not connect to redis: %s\n", c->errstr);
+        return false;
+      }
+  } catch(std::exception const& e) {
+      LOG_OPER("Could not connect to redis: %s", e.what());
+      return false;
+  }
+  
+  return true;
+}
+
+bool RedisStore::isOpen() {
+  return false;
+}
+
+void RedisStore::configure(pStoreConf configuration) {
+  configuration->getString("redis_host", redisHost);
+  configuration->getUnsigned("redis_port", redisPort);
+}
+
+void RedisStore::close() {
+	redisFree(c);	
+}
+
+bool RedisStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages) {
+  redisReply *reply;
+  char key[60];
+  
+  // Generate key
+  time_t rawtime;
+  struct tm* local;
+  time ( &rawtime );
+  local = localtime(&rawtime);
+  int year = local->tm_year;
+  int month = local->tm_mon;
+  int day = local->tm_mday;
+  int hour = local->tm_hour;
+  
+  int n = sprintf(key, "log:%d:%d:%d:%d:%s", year + 1900, month + 1, day, hour, categoryHandled.c_str());
+  
+  // Open redis connection
+  open();
+  
+  // Log messages
+  for (logentry_vector_t::iterator iter = messages->begin();
+       iter != messages->end();
+       ++iter) {
+       
+    std::string message = (*iter)->message;
+    char msg[600];
+    unsigned long int leng = message.length();
+    memcpy(&msg, message.c_str(), leng);
+    msg[leng - 1] = '\0';
+    
+    char cmd[800];
+    sprintf(cmd, "LPUSH %s %%s", key);
+    
+    try {
+      reply = (redisReply*)redisCommand(c, cmd, msg);
+    } catch(std::exception const& e) {
+      LOG_OPER("Could not connect to redis: %s", e.what());
+      return false;
+    }
+
+    freeReplyObject(reply);
+  }
+  
+  // Close redis connection
+  close();
+
+  return true;
+}
+
+void RedisStore::flush() {
+}
+
+bool RedisStore::readOldest(/*out*/ boost::shared_ptr<logentry_vector_t> messages,
+                       struct tm* now) {
+  return true;
+}
+
+bool RedisStore::replaceOldest(boost::shared_ptr<logentry_vector_t> messages,
+                              struct tm* now) {
+  return true;
+}
+
+void RedisStore::deleteOldest(struct tm* now) {
+}
+
+bool RedisStore::empty(struct tm* now) {
+  return true;
+}
+
+// ############################################################################
+
+
 
-NullStore::NullStore(StoreQueue* storeq,
-                     const std::string& category,
-                     bool multi_category)
-  : Store(storeq, category, "null", multi_category)
+NullStore::NullStore(const std::string& category, bool multi_category)
+  : Store(category, "null", multi_category)
 {}
 
 NullStore::~NullStore() {
 }
 
 boost::shared_ptr<Store> NullStore::copy(const std::string &category) {
-  NullStore *store = new NullStore(storeQueue, category, multiCategory);
+  NullStore *store = new NullStore(category, multiCategory);
   shared_ptr<Store> copied = shared_ptr<Store>(store);
   return copied;
 }
@@ -2558,15 +2307,14 @@ bool NullStore::isOpen() {
   return true;
 }
 
-void NullStore::configure(pStoreConf configuration, pStoreConf parent) {
-  Store::configure(configuration, parent);
+void NullStore::configure(pStoreConf) {
 }
 
 void NullStore::close() {
 }
 
 bool NullStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages) {
-  g_Handler->incCounter(categoryHandled, "ignored", messages->size());
+  g_Handler->incrementCounter("ignored", messages->size());
   return true;
 }
 
@@ -2590,17 +2338,15 @@ bool NullStore::empty(struct tm* now) {
   return true;
 }
 
-MultiStore::MultiStore(StoreQueue* storeq,
-                      const std::string& category,
-                      bool multi_category)
-  : Store(storeq, category, "multi", multi_category) {
+MultiStore::MultiStore(const std::string& category, bool multi_category)
+  : Store(category, "multi", multi_category) {
 }
 
 MultiStore::~MultiStore() {
 }
 
 boost::shared_ptr<Store> MultiStore::copy(const std::string &category) {
-  MultiStore *store = new MultiStore(storeQueue, category, multiCategory);
+  MultiStore *store = new MultiStore(category, multiCategory);
   store->report_success = this->report_success;
   boost::shared_ptr<Store> tmp_copy;
   for (std::vector<boost::shared_ptr<Store> >::iterator iter = stores.begin();
@@ -2641,8 +2387,7 @@ bool MultiStore::isOpen() {
   return (report_success == SUCCESS_ALL) ? all_result : any_result;
 }
 
-void MultiStore::configure(pStoreConf configuration, pStoreConf parent) {
-  Store::configure(configuration, parent);
+void MultiStore::configure(pStoreConf configuration) {
   /**
    * in this store, we look for other numbered stores
    * in the following fashion:
@@ -2703,11 +2448,10 @@ void MultiStore::configure(pStoreConf configuration, pStoreConf parent) {
         return;
       } else {
         // add it to the list
-        cur_store = createStore(storeQueue, cur_type, categoryHandled, false,
-                                multiCategory);
+        cur_store = createStore(cur_type, categoryHandled, false, multiCategory);
         LOG_OPER("[%s] MULTI: Configured store of type %s successfully.",
                  categoryHandled.c_str(), cur_type.c_str());
-        cur_store->configure(cur_conf, storeConf);
+        cur_store->configure(cur_conf);
         stores.push_back(cur_store);
       }
     }
@@ -2745,7 +2489,6 @@ bool MultiStore::handleMessages(boost::shared_ptr<logentry_vector_t> messages) {
   return (report_success == SUCCESS_ALL) ? all_result : any_result;
 }
 
-// Call periodicCheck on all contained stores
 void MultiStore::periodicCheck() {
   for (std::vector<boost::shared_ptr<Store> >::iterator iter = stores.begin();
        iter != stores.end();
@@ -2762,23 +2505,20 @@ void MultiStore::flush() {
   }
 }
 
-CategoryStore::CategoryStore(StoreQueue* storeq,
-                             const std::string& category,
-                             bool multiCategory)
-  : Store(storeq, category, "category", multiCategory) {
+CategoryStore::CategoryStore(const std::string& category, bool multiCategory)
+  : Store(category, "category", multiCategory) {
 }
 
-CategoryStore::CategoryStore(StoreQueue* storeq,
-                             const std::string& category,
+CategoryStore::CategoryStore(const std::string& category,
                              const std::string& name, bool multiCategory)
-  : Store(storeq, category, name, multiCategory) {
+  : Store(category, name, multiCategory) {
 }
 
 CategoryStore::~CategoryStore() {
 }
 
 boost::shared_ptr<Store> CategoryStore::copy(const std::string &category) {
-  CategoryStore *store = new CategoryStore(storeQueue, category, multiCategory);
+  CategoryStore *store = new CategoryStore(category, multiCategory);
 
   store->modelStore = modelStore->copy(category);
 
@@ -2810,8 +2550,7 @@ bool CategoryStore::isOpen() {
   return true;
 }
 
-void CategoryStore::configure(pStoreConf configuration, pStoreConf parent) {
-  Store::configure(configuration, parent);
+void CategoryStore::configure(pStoreConf configuration) {
   /**
    *  Parse the store defined and use this store as a model to create a
    *  new store for every new category we see later.
@@ -2840,19 +2579,17 @@ void CategoryStore::configure(pStoreConf configuration, pStoreConf parent) {
       return;
     }
 
-    configureCommon(cur_conf, parent, cur_type);
+    configureCommon(cur_conf, cur_type);
   }
 }
 
 void CategoryStore::configureCommon(pStoreConf configuration,
-                                    pStoreConf parent,
                                     const string type) {
-  Store::configure(configuration, parent);
   // initialize model store
-  modelStore = createStore(storeQueue, type, categoryHandled, false, false);
+  modelStore = createStore(type, categoryHandled, false, false);
   LOG_OPER("[%s] %s: Configured store of type %s successfully.",
            categoryHandled.c_str(), getType().c_str(), type.c_str());
-  modelStore->configure(configuration, parent);
+  modelStore->configure(configuration);
 }
 
 void CategoryStore::close() {
@@ -2930,28 +2667,25 @@ void CategoryStore::flush() {
   }
 }
 
-MultiFileStore::MultiFileStore(StoreQueue* storeq,
-                               const std::string& category,
-                               bool multi_category)
-  : CategoryStore(storeq, category, "MultiFileStore", multi_category) {
+MultiFileStore::MultiFileStore(const std::string& category, bool multi_category)
+  : CategoryStore(category, "MultiFileStore", multi_category) {
 }
 
 MultiFileStore::~MultiFileStore() {
 }
 
-void MultiFileStore::configure(pStoreConf configuration, pStoreConf parent) {
-  configureCommon(configuration, parent, "file");
+void MultiFileStore::configure(pStoreConf configuration) {
+  configureCommon(configuration, "file");
 }
 
-ThriftMultiFileStore::ThriftMultiFileStore(StoreQueue* storeq,
-                                          const std::string& category,
+ThriftMultiFileStore::ThriftMultiFileStore(const std::string& category,
                                            bool multi_category)
-  : CategoryStore(storeq, category, "ThriftMultiFileStore", multi_category) {
+  : CategoryStore(category, "ThriftMultiFileStore", multi_category) {
 }
 
 ThriftMultiFileStore::~ThriftMultiFileStore() {
 }
 
-void ThriftMultiFileStore::configure(pStoreConf configuration, pStoreConf parent) {
-  configureCommon(configuration, parent, "thriftfile");
+void ThriftMultiFileStore::configure(pStoreConf configuration) {
+  configureCommon(configuration, "thriftfile");
 }
diff --git a/src/store.h b/src/store.h
index adb0223..7968526 100644
--- a/src/store.h
+++ b/src/store.h
@@ -22,7 +22,6 @@
 // @author Avinash Lakshman
 // @author Anthony Giardullo
 // @author Jan Oravec
-// @author John Song
 
 #ifndef SCRIBE_STORE_H
 #define SCRIBE_STORE_H
@@ -31,10 +30,10 @@
 #include "conf.h"
 #include "file.h"
 #include "conn_pool.h"
-#include "store_queue.h"
-#include "network_dynamic_config.h"
-
-class StoreQueue;
+extern "C" {
+  #include <hiredis.h>
+  #include <time.h>
+}
 
 /* defines used by the store class */
 enum roll_period_t {
@@ -53,18 +52,17 @@ class Store {
  public:
   // Creates an object of the appropriate subclass.
   static boost::shared_ptr<Store>
-    createStore(StoreQueue* storeq,
-                const std::string& type, const std::string& category,
+    createStore(const std::string& type, const std::string& category,
                 bool readable = false, bool multi_category = false);
 
-  Store(StoreQueue* storeq, const std::string& category,
-        const std::string &type, bool multi_category = false);
+  Store(const std::string& category, const std::string &type,
+        bool multi_category = false);
   virtual ~Store();
 
   virtual boost::shared_ptr<Store> copy(const std::string &category) = 0;
   virtual bool open() = 0;
   virtual bool isOpen() = 0;
-  virtual void configure(pStoreConf configuration, pStoreConf parent);
+  virtual void configure(pStoreConf configuration) = 0;
   virtual void close() = 0;
 
   // Attempts to store messages and returns true if successful.
@@ -96,8 +94,6 @@ class Store {
   // Don't ever take this lock for multiple stores at the same time
   pthread_mutex_t statusMutex;
 
-  StoreQueue* storeQueue;
-  pStoreConf storeConf;
  private:
   // disallow copy, assignment, and empty construction
   Store(Store& rhs);
@@ -110,14 +106,13 @@ class Store {
  */
 class FileStoreBase : public Store {
  public:
-  FileStoreBase(StoreQueue* storeq,
-                const std::string& category,
-                const std::string &type, bool multi_category);
+  FileStoreBase(const std::string& category, const std::string &type,
+                bool multi_category);
   ~FileStoreBase();
 
   virtual void copyCommon(const FileStoreBase *base);
   bool open();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
   void periodicCheck();
 
  protected:
@@ -127,8 +122,7 @@ class FileStoreBase : public Store {
   virtual void rotateFile(time_t currentTime = 0);
 
 
-  // appends information about the current file to a log file in the same
-  // directory
+  // appends information about the current file to a log file in the same directory
   virtual void printStats();
 
   // Returns the number of bytes to pad to align to the specified block size
@@ -166,7 +160,6 @@ class FileStoreBase : public Store {
   bool writeCategory;
   bool createSymlink;
   bool writeStats;
-  bool rotateOnReopen;
 
   // State
   unsigned long currentSize;
@@ -191,20 +184,19 @@ class FileStoreBase : public Store {
 class FileStore : public FileStoreBase {
 
  public:
-  FileStore(StoreQueue* storeq, const std::string& category,
-            bool multi_category, bool is_buffer_file = false);
+  FileStore(const std::string& category, bool multi_category,
+            bool is_buffer_file = false);
   ~FileStore();
 
   boost::shared_ptr<Store> copy(const std::string &category);
   bool handleMessages(boost::shared_ptr<logentry_vector_t> messages);
   bool isOpen();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
   void close();
   void flush();
 
   // Each read does its own open and close and gets the whole file.
-  // This is separate from the write file, and not really a consistent
-  // interface.
+  // This is separate from the write file, and not really a consistent interface.
   bool readOldest(/*out*/ boost::shared_ptr<logentry_vector_t> messages,
                   struct tm* now);
   virtual bool replaceOldest(boost::shared_ptr<logentry_vector_t> messages,
@@ -229,7 +221,6 @@ class FileStore : public FileStoreBase {
   // disallow copy, assignment, and empty construction
   FileStore(FileStore& rhs);
   FileStore& operator=(FileStore& rhs);
-  long lostBytes_;
 };
 
 /*
@@ -237,16 +228,14 @@ class FileStore : public FileStoreBase {
  */
 class ThriftFileStore : public FileStoreBase {
  public:
-  ThriftFileStore(StoreQueue* storeq,
-                  const std::string& category,
-                  bool multi_category);
+  ThriftFileStore(const std::string& category, bool multi_category);
   ~ThriftFileStore();
 
   boost::shared_ptr<Store> copy(const std::string &category);
   bool handleMessages(boost::shared_ptr<logentry_vector_t> messages);
   bool open();
   bool isOpen();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
   void close();
   void flush();
   bool createFileDirectory();
@@ -280,16 +269,14 @@ class ThriftFileStore : public FileStoreBase {
 class BufferStore : public Store {
 
  public:
-  BufferStore(StoreQueue* storeq,
-              const std::string& category,
-              bool multi_category);
+  BufferStore(const std::string& category, bool multi_category);
   ~BufferStore();
 
   boost::shared_ptr<Store> copy(const std::string &category);
   bool handleMessages(boost::shared_ptr<logentry_vector_t> messages);
   bool open();
   bool isOpen();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
   void close();
   void flush();
   void periodicCheck();
@@ -311,50 +298,24 @@ class BufferStore : public Store {
     SENDING_BUFFER,  // connected to primary and sending data from secondary
   };
 
-  // handles state pre and post conditions
-  void changeState(buffer_state_t new_state);
+  void changeState(buffer_state_t new_state); // handles state pre and post conditions
   const char* stateAsString(buffer_state_t state);
 
-  void setNewRetryInterval(bool);
+  time_t getNewRetryInterval(); // generates a random interval based on config
 
   // configuration
-  unsigned long bufferSendRate;   // number of buffer files
-                                  // sent each periodicCheck
+  unsigned long maxQueueLength;   // in number of messages
+  unsigned long bufferSendRate;   // number of buffer files sent each periodicCheck
   time_t avgRetryInterval;        // in seconds, for retrying primary store open
   time_t retryIntervalRange;      // in seconds
   bool   replayBuffer;            // whether to send buffers from
                                   // secondary store to primary
-  bool adaptiveBackoff;           // Adaptive backoff mode indicator
-  unsigned long minRetryInterval; // The min the retryInterval can become
-  unsigned long maxRetryInterval; // The max the retryInterval can become
-  unsigned long maxRandomOffset;  // The max random offset added
-                                  // to the retry interval
-
 
   // state
-  time_t retryInterval;           // the current retry interval in seconds
-  unsigned long numContSuccess;   // number of continuous successful sends
   buffer_state_t state;
+  time_t lastWriteTime;
   time_t lastOpenAttempt;
-
-  bool flushStreaming;            // When flushStreaming is set to true,
-                                  // incoming messages to a buffere store
-                                  // that still has buffereed data in the
-                                  // secondary store, i.e. buffer store in
-                                  // SENDING_BUFFER phase, will be sent to the
-                                  // primary store directly.  If false,
-                                  // then in coming messages will first
-                                  // be written to secondary store, and
-                                  // later flushed out to the primary
-                                  // store.
-
-  double maxByPassRatio;          // During the buffer flushing phase, if
-                                  // flushStreaming is enabled, the max
-                                  // size of message queued before buffer
-                                  // flushing yielding to sending current
-                                  // incoming messages is calculated by
-                                  // multiple max_queue_size with
-                                  // buffer_bypass_max_ratio.
+  time_t retryInterval;
 
  private:
   // disallow copy, assignment, and empty construction
@@ -371,37 +332,31 @@ class BufferStore : public Store {
 class NetworkStore : public Store {
 
  public:
-  NetworkStore(StoreQueue* storeq,
-               const std::string& category,
-               bool multi_category);
+  NetworkStore(const std::string& category, bool multi_category);
   ~NetworkStore();
 
   boost::shared_ptr<Store> copy(const std::string &category);
   bool handleMessages(boost::shared_ptr<logentry_vector_t> messages);
   bool open();
   bool isOpen();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
   void close();
   void flush();
-  void periodicCheck();
 
  protected:
   static const long int DEFAULT_SOCKET_TIMEOUT_MS = 5000; // 5 sec timeout
 
   // configuration
   bool useConnPool;
-  bool serviceBased;
+  bool smcBased;
   long int timeout;
   std::string remoteHost;
   unsigned long remotePort; // long because it works with config code
-  std::string serviceName;
+  std::string smcService;
   std::string serviceOptions;
   server_vector_t servers;
   unsigned long serviceCacheTimeout;
   time_t lastServiceCheck;
-  // if true do not update status to reflect failure to connect
-  bool ignoreNetworkError;
-  NetworkDynamicConfigMod* configmod;
 
   // state
   bool opened;
@@ -421,16 +376,14 @@ class NetworkStore : public Store {
 class BucketStore : public Store {
 
  public:
-  BucketStore(StoreQueue* storeq,
-              const std::string& category,
-              bool multi_category);
+  BucketStore(const std::string& category, bool multi_category);
   ~BucketStore();
 
   boost::shared_ptr<Store> copy(const std::string &category);
   bool handleMessages(boost::shared_ptr<logentry_vector_t> messages);
   bool open();
   bool isOpen();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
   void close();
   void flush();
   void periodicCheck();
@@ -468,28 +421,65 @@ class BucketStore : public Store {
 };
 
 /*
+ * This store will log to a redis server
+ */
+class RedisStore : public Store {
+
+ public:
+  RedisStore(const std::string& category, bool multi_category);
+  virtual ~RedisStore();
+
+  boost::shared_ptr<Store> copy(const std::string &category);
+  bool open();
+  bool isOpen();
+  void configure(pStoreConf configuration);
+  void close();
+
+  bool handleMessages(boost::shared_ptr<logentry_vector_t> messages);
+  void flush();
+
+  // configuration
+  std::string redisHost;
+  unsigned long int redisPort;
+  
+  // redis
+  redisContext *c;
+
+  // null stores are readable, but you never get anything
+  virtual bool readOldest(/*out*/ boost::shared_ptr<logentry_vector_t> messages,                          struct tm* now);
+  virtual bool replaceOldest(boost::shared_ptr<logentry_vector_t> messages,
+                             struct tm* now);
+  virtual void deleteOldest(struct tm* now);
+  virtual bool empty(struct tm* now);
+
+
+ private:
+  // disallow empty constructor, copy and assignment
+  RedisStore();
+  RedisStore(Store& rhs);
+  RedisStore& operator=(Store& rhs);
+};
+
+/*
  * This store intentionally left blank.
  */
 class NullStore : public Store {
 
  public:
-  NullStore(StoreQueue* storeq,
-            const std::string& category,
-            bool multi_category);
+  NullStore(const std::string& category, bool multi_category);
   virtual ~NullStore();
 
   boost::shared_ptr<Store> copy(const std::string &category);
   bool open();
   bool isOpen();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
   void close();
 
   bool handleMessages(boost::shared_ptr<logentry_vector_t> messages);
   void flush();
 
   // null stores are readable, but you never get anything
-  virtual bool readOldest(boost::shared_ptr<logentry_vector_t> messages,
-                          struct tm* now);
+  virtual bool readOldest(/*out*/ boost::shared_ptr<logentry_vector_t> messages,                          struct tm* now);
   virtual bool replaceOldest(boost::shared_ptr<logentry_vector_t> messages,
                              struct tm* now);
   virtual void deleteOldest(struct tm* now);
@@ -509,15 +499,13 @@ class NullStore : public Store {
  */
 class MultiStore : public Store {
  public:
-  MultiStore(StoreQueue* storeq,
-             const std::string& category,
-             bool multi_category);
+  MultiStore(const std::string& category, bool multi_category);
   ~MultiStore();
 
   boost::shared_ptr<Store> copy(const std::string &category);
   bool open();
   bool isOpen();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
   void close();
 
   bool handleMessages(boost::shared_ptr<logentry_vector_t> messages);
@@ -553,18 +541,15 @@ class MultiStore : public Store {
  */
 class CategoryStore : public Store {
  public:
-  CategoryStore(StoreQueue* storeq,
-                const std::string& category,
-                bool multi_category);
-  CategoryStore(StoreQueue* storeq,
-                const std::string& category,
-                const std::string& name, bool multiCategory);
+  CategoryStore(const std::string& category, bool multi_category);
+  CategoryStore(const std::string& category, const std::string& name,
+                bool multiCategory);
   ~CategoryStore();
 
   boost::shared_ptr<Store> copy(const std::string &category);
   bool open();
   bool isOpen();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
   void close();
 
   bool handleMessages(boost::shared_ptr<logentry_vector_t> messages);
@@ -572,8 +557,7 @@ class CategoryStore : public Store {
   void flush();
 
  protected:
-  void configureCommon(pStoreConf configuration, pStoreConf parent,
-                       const std::string type);
+  void configureCommon(pStoreConf configuration, const std::string type);
   boost::shared_ptr<Store> modelStore;
   std::map<std::string, boost::shared_ptr<Store> > stores;
 
@@ -590,11 +574,9 @@ class CategoryStore : public Store {
  */
 class MultiFileStore : public CategoryStore {
  public:
-  MultiFileStore(StoreQueue* storeq,
-                const std::string& category,
-                bool multi_category);
+  MultiFileStore(const std::string& category, bool multi_category);
   ~MultiFileStore();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
 
  private:
   MultiFileStore();
@@ -609,11 +591,9 @@ class MultiFileStore : public CategoryStore {
  */
 class ThriftMultiFileStore : public CategoryStore {
  public:
-  ThriftMultiFileStore(StoreQueue* storeq,
-                       const std::string& category,
-                       bool multi_category);
+  ThriftMultiFileStore(const std::string& category, bool multi_category);
   ~ThriftMultiFileStore();
-  void configure(pStoreConf configuration, pStoreConf parent);
+  void configure(pStoreConf configuration);
 
 
  private:
-- 
1.7.3.5

